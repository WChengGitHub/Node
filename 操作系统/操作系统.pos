{"diagram":{"image":{"height":200,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","width":200,"y":0,"x":0},"elements":{"id":"root","title":"操作系统","leftChildren":[{"id":"77a368e05cee","title":"线程","children":[{"id":"06bd235bf4b9","title":"背景","parent":"77a368e05cee","children":[{"id":"eff5556e1fa1","title":"进程在创建、撤销和切换中消耗的代价比较大","parent":"06bd235bf4b9","children":[]}]},{"id":"bdb67e30ca93","title":"定义","parent":"77a368e05cee","children":[{"id":"70382317d468","title":"线程作为调度和分配的基本单位，而进程作为拥有资源的基本单位","parent":"bdb67e30ca93","children":[]},{"id":"72272f1c89f3","title":"TCP是线程控制块，记录线程的基本情况","parent":"bdb67e30ca93","children":[]}]}],"parent":"root","collapsed":true},{"id":"0337d91b782b","title":"存储器管理","children":[{"id":"7aea29c281eb","title":"存储器的层次结构","parent":"0337d91b782b","children":[{"id":"6da031e83a8c","title":"CPU寄存器","parent":"7aea29c281eb","children":[]},{"id":"49456be806cd","title":"主存","parent":"7aea29c281eb","children":[{"id":"152defb0ee06","title":"高速缓存","parent":"49456be806cd","children":[{"id":"b6b54672911d","title":"减少CPU对主存区的访问次数","parent":"152defb0ee06","children":[]}]},{"id":"07d400a7280e","title":"主存储器","parent":"49456be806cd","children":[]},{"id":"f489fbb97313","title":"磁盘缓存","parent":"49456be806cd","children":[{"id":"d4458beb442e","title":"缓和CPU对主存的访问速度和磁盘的I/O速度不匹配的问题","parent":"f489fbb97313","children":[]}]}]},{"id":"53747f6a253e","title":"铺存","parent":"7aea29c281eb","children":[{"id":"62a057293df9","title":"固定磁盘","parent":"53747f6a253e","children":[]},{"id":"ab87ff811b6a","title":"可移动存储介质","parent":"53747f6a253e","children":[]}]}],"collapsed":true},{"id":"97b105397850","title":"连续分配存储管理方式","children":[{"id":"2437ba8139ee","title":"单一连续分配","children":[{"id":"e0ba7327f01f","title":"用户区内存只有一道用户程序","children":[],"parent":"2437ba8139ee"}],"parent":"97b105397850"},{"id":"bee81c03d96c","title":"固定分期分配","children":[{"id":"229a641db86a","title":"分区大小相等","children":[],"parent":"bee81c03d96c"},{"id":"7284654a9176","title":"分区大小不相等","children":[],"parent":"bee81c03d96c"}],"parent":"97b105397850"},{"id":"d224f62d6bb4","title":"动态分区分配","children":[{"id":"4a51ef58b294","title":"算法","children":[{"id":"2838af36efe8","title":"首次适应算法","children":[],"parent":"4a51ef58b294"},{"id":"ada66a8ae0bf","title":"循环首次适应算法","children":[],"parent":"4a51ef58b294"},{"id":"ec5108fa9422","title":"最佳适应算法","children":[{"id":"1f7de0bf9602","title":"容易产生碎片","children":[],"parent":"ec5108fa9422"}],"parent":"4a51ef58b294"},{"id":"f9d32fd54d9a","title":"最坏适应算法","children":[{"id":"e95d446d0266","title":"缺乏大分区","children":[],"parent":"f9d32fd54d9a"}],"parent":"4a51ef58b294"},{"id":"5326fc816af5","title":"紧凑","children":[],"parent":"4a51ef58b294"}],"parent":"d224f62d6bb4"}],"parent":"97b105397850"}],"parent":"0337d91b782b","collapsed":true},{"id":"099e4bbfb15c","title":"对换","children":[{"id":"678d15e8b26a","title":"把暂时不能运行的进程或者程序和数据放到外存","children":[],"parent":"099e4bbfb15c"}],"parent":"0337d91b782b","collapsed":true},{"id":"5fe071b2fc80","title":"分页存储管理方式","children":[{"id":"63ed4376431f","title":"核心概念","children":[{"id":"b60798f60840","title":"页面","children":[{"id":"c36b21ed3c65","title":"把进程的逻辑空间分成若干列，为每一列分配一个物理块","children":[],"parent":"b60798f60840"}],"parent":"63ed4376431f"},{"id":"2940caac877e","title":"地址结构","children":[{"id":"e1062daa93f7","title":"页号+位偏移量","children":[],"parent":"2940caac877e"}],"parent":"63ed4376431f"},{"id":"1507968f2f7d","title":"页面","children":[{"id":"5f9d1802ebcc","title":"记录着页号和块号的对应关系","children":[],"parent":"1507968f2f7d"}],"parent":"63ed4376431f"},{"id":"b0d8d6a9e584","title":"快表","children":[{"id":"9e576749cdfe","title":"存储着当前访问的页号","children":[],"parent":"b0d8d6a9e584"},{"id":"a696063301ad","title":"背景","children":[{"id":"bd250640da7e","title":"cpu获取数据时需要两次访问内存，第一次是访问页表得到物理地址，第二次从地址中取数据","children":[],"parent":"a696063301ad"}],"parent":"b0d8d6a9e584"}],"parent":"63ed4376431f"}],"parent":"5fe071b2fc80"}],"parent":"0337d91b782b","collapsed":true},{"id":"de8f5355ea3b","title":"分段存储管理方式","children":[{"id":"934c808da585","title":"背景","children":[{"id":"1ecdb6eca9cf","title":"用户一般把自己的作业按照逻辑关系若干段","children":[],"parent":"934c808da585"},{"id":"074ece1ce09c","title":"信息共享","children":[{"id":"979fbdb1228a","title":"居于分页式的共享，共享的数据可能跨数十个页面","children":[],"parent":"074ece1ce09c"}],"parent":"934c808da585"},{"id":"ed943fc6300c","title":"信息包含","children":[],"parent":"934c808da585"}],"parent":"de8f5355ea3b"},{"id":"b8f6eb459588","title":"核心概念","children":[{"id":"ba8fc96b90a1","title":"分段地址","children":[{"id":"1254ab957832","title":"段号+段内地址","children":[],"parent":"ba8fc96b90a1"}],"parent":"b8f6eb459588"},{"id":"29d382563562","title":"段表","children":[{"id":"43510b3d7c5f","title":"段号+段长+段基址","children":[],"parent":"29d382563562"}],"parent":"b8f6eb459588"}],"parent":"de8f5355ea3b"},{"id":"498b02b47a52","title":"定义","children":[{"id":"085b86971955","title":"把作业按照逻辑关系按照逻辑关系划分成若干段","children":[],"parent":"498b02b47a52"}],"parent":"de8f5355ea3b"}],"parent":"0337d91b782b","collapsed":true},{"id":"1bada408a310","title":"段页式管理方式","children":[{"id":"9eb3dde34f8c","title":"定义","children":[{"id":"e38706312df3","title":"按照逻辑关系把作业分段，段内分页","children":[],"parent":"9eb3dde34f8c"}],"parent":"1bada408a310"},{"id":"4e6fa0a6f975","title":"背景","children":[{"id":"8403b62aac46","title":"分段管理方式需要连续的存储空间","children":[],"parent":"4e6fa0a6f975"}],"parent":"1bada408a310"}],"parent":"0337d91b782b","collapsed":true}],"parent":"root","collapsed":true},{"id":"c7f6b557377e","title":"输入输出系统","children":[],"parent":"root"},{"id":"f1df513432fd","title":"磁盘管理","children":[],"parent":"root"}],"structure":"mind_free","root":true,"theme":"paper","children":[{"id":"4b198bfdc4ce","title":"进程","children":[{"id":"f1b72e1f02b7","title":"定义","children":[{"id":"b0999f2220b8","title":"进程是由程序段、数据段、PCB组成","children":[],"parent":"f1b72e1f02b7"},{"id":"28b10aef3830","title":"PCB是是一种数据结构，存储着进程标志符、处理机状态、进程调度的信息、进程的控制信息","parent":"f1b72e1f02b7","children":[]},{"id":"e73eca91609f","title":"进程是资源和独立调度的基本单位","parent":"f1b72e1f02b7","children":[]}],"parent":"4b198bfdc4ce"},{"id":"f8ba6662b0f0","title":"状态","children":[{"id":"6f5732eeff5e","title":"就绪","children":[{"id":"2fb152d2b74b","title":"进程分配到除了CPU之外的所有资源","children":[],"parent":"6f5732eeff5e"}],"parent":"f8ba6662b0f0"},{"id":"15a1fc4e1ffa","title":"阻塞","children":[{"id":"131021f8ef2b","title":"正在执行的进程由于一些原因无法继续执行","children":[],"parent":"15a1fc4e1ffa"}],"parent":"f8ba6662b0f0"},{"id":"58df1a0e710b","title":"执行","children":[{"id":"7f6156d7dcd2","title":"就绪转态的进程获得CPU","children":[],"parent":"58df1a0e710b"}],"parent":"f8ba6662b0f0"},{"id":"61aa377863c2","title":"转态转换","parent":"f8ba6662b0f0","children":[{"id":"0b26668d2a2d","title":"执行状态的进程的时间片走完之后就进入就绪转态","parent":"61aa377863c2","children":[]},{"id":"9229bea27c7e","title":"阻塞转态的进程在阻塞事件消失后就进入就绪状态","parent":"61aa377863c2","children":[]}]}],"parent":"4b198bfdc4ce"},{"id":"70a6ca91502f","title":"进程同步","children":[{"id":"9d4317f826b5","title":"核心概念","children":[{"id":"6e0e3d288c56","title":"临界资源","children":[{"id":"10f6170df87d","title":"硬件资源例如打印机","children":[],"parent":"6e0e3d288c56"}],"parent":"9d4317f826b5"},{"id":"292bf9e707ad","title":"临界区","children":[{"id":"010ec08f9474","title":"访问临界资源的代码","children":[],"parent":"292bf9e707ad"}],"parent":"9d4317f826b5"},{"id":"038c701c2ae7","title":"进入区","children":[{"id":"496e9bac8791","title":"在临界区前用于检查临界资源的代码","children":[],"parent":"038c701c2ae7"}],"parent":"9d4317f826b5"},{"id":"25059aca40db","title":"退出区","children":[{"id":"c6af4a80597b","title":"恢复进入区代码的修改","parent":"25059aca40db","children":[]}],"parent":"9d4317f826b5"}],"parent":"70a6ca91502f"},{"id":"29ddb104d923","title":"同步机制","parent":"70a6ca91502f","children":[{"id":"06837a35459e","title":"硬件同步机制","parent":"29ddb104d923","children":[{"id":"5505f1554e10","title":"关中断","parent":"06837a35459e","children":[{"id":"4ec139365e48","title":"进程在临界区执行时，系统不响应中段","parent":"5505f1554e10","children":[]}]}]},{"id":"4c5f09bec01a","title":"信号量同步机制","parent":"29ddb104d923","children":[{"id":"44824e243a28","title":"记录型信号量","parent":"4c5f09bec01a","children":[{"id":"f9d7953f2534","title":"实现","children":[{"id":"4d1700b80a85","title":"数据结构记录资源数目、和等待的进程链表","children":[],"parent":"f9d7953f2534"},{"id":"8259963d2be7","title":"等待函数","parent":"f9d7953f2534","children":[{"id":"73fc0f40d65e","title":"先让资源数目减1，如果数目&lt;0，就把该进程放进等待列表","parent":"8259963d2be7","children":[]}]},{"id":"4a28d0c3a9a1","title":"唤醒函数","parent":"f9d7953f2534","children":[{"id":"5cce8b0db8a3","title":"先让资源数目+1，如果数目&lt;=0,就从等待队列中唤醒一个进程","parent":"4a28d0c3a9a1","children":[]}]}],"parent":"44824e243a28"},{"id":"2c3bad7f30dd","title":"应用场景","parent":"44824e243a28","children":[{"id":"2e8341371334","title":"生产者-消费者问题","parent":"2c3bad7f30dd","children":[]}]}]}]},{"id":"d13db7f62bb8","title":"规则","parent":"29ddb104d923","children":[{"id":"f960dc9d7385","title":"空闲让进","parent":"d13db7f62bb8","children":[]},{"id":"b34523845cd5","title":"满则等待","parent":"d13db7f62bb8","children":[]},{"id":"cb79c4fff822","title":"有限等待","parent":"d13db7f62bb8","children":[]},{"id":"35d0461e06be","title":"让权等待","parent":"d13db7f62bb8","children":[{"id":"5c00ee4fda96","title":"进程不能进入临界区后，应立即释放CPU","parent":"35d0461e06be","children":[]}]}]}]}],"parent":"4b198bfdc4ce"},{"id":"133d22a8ecc2","title":"进程通信","parent":"4b198bfdc4ce","children":[{"id":"6717c2bae906","title":"共享存储区通信方式","parent":"133d22a8ecc2","children":[{"id":"11d668ad5a7c","title":"在内存中划出一块区域，诸进程可以通过该存储区交互数据","parent":"6717c2bae906","children":[]}]},{"id":"bcc50a01f68e","title":"管道通信方式","children":[{"id":"1ca1c89b30ec","title":"读进程和写进程通过一个共享文件进行数据交换","children":[],"parent":"bcc50a01f68e"}],"parent":"133d22a8ecc2"},{"id":"9d1f10e8d63c","title":"消息传递系统","children":[{"id":"f1da190dd3a5","title":"进程把数据封装在消息中，通过OS提供的通信命令进行进程之间的通信，比如网络中的报文","children":[],"parent":"9d1f10e8d63c"}],"parent":"133d22a8ecc2"},{"id":"06097adbabcd","title":"客户机-服务器系统","parent":"133d22a8ecc2","children":[{"id":"9e7608987246","title":"进程通过网络协议交换信息","parent":"06097adbabcd","children":[]}]}]}],"parent":"root","collapsed":true},{"id":"9aafba07bba7","title":"处理机调度","children":[{"id":"08dd641b4c91","title":"高级调度（作业调度）","children":[{"id":"07f0666b7cb9","title":"定义","children":[{"id":"05739f2568c6","title":"调度的对象是作业，根据调度算法把作业调到内存","parent":"07f0666b7cb9","children":[]}],"parent":"08dd641b4c91"},{"id":"26338ff1d35b","title":"核心概念","parent":"08dd641b4c91","children":[{"id":"9462cd281a3e","title":"作业","parent":"26338ff1d35b","children":[{"id":"9c638707540f","title":"包含程序、数据和作业说明书","parent":"9462cd281a3e","children":[]}]},{"id":"fd260003222b","title":"作业步","parent":"26338ff1d35b","children":[{"id":"ce3ffee5a7fa","title":"对作业进行加工的步骤","parent":"fd260003222b","children":[]}]},{"id":"e87888c911df","title":"作业控制块（JCB）","parent":"26338ff1d35b","children":[{"id":"680a5648aec8","title":"保存着系统对作业进行管理和调度的全部信息","parent":"e87888c911df","children":[]}]},{"id":"280655b39e81","title":"三个阶段和三个状态","children":[{"id":"a8698ca71b25","title":"收容阶段","children":[{"id":"12b04e4c627c","title":"为作业建立JCB,放入作业后备队列，此时就是“后备状态”","children":[],"parent":"a8698ca71b25"}],"parent":"280655b39e81"},{"id":"ae92b70e8406","title":"运行阶段","children":[{"id":"91ec947c2af2","title":"为作业分配资源和建立进程，把作业放入就绪队列，直到运行结束（运行状态）","children":[],"parent":"ae92b70e8406"}],"parent":"280655b39e81"},{"id":"b8fc1889028a","title":"完成阶段","children":[{"id":"1b1a59f593c0","title":"系统回收JCB和资源","children":[],"parent":"b8fc1889028a"}],"parent":"280655b39e81"}],"parent":"26338ff1d35b"}]},{"id":"3211cbd19e9a","title":"调度的算法","children":[{"id":"63f4f5e1d387","title":"先来先服务（FCFS）","children":[],"parent":"3211cbd19e9a"},{"id":"48f22a690345","title":"短作业优先（SJF）","children":[],"parent":"3211cbd19e9a"},{"id":"a1c416f0282f","title":"优先级调度算法","children":[],"parent":"3211cbd19e9a"},{"id":"fd6690ea57e1","title":"高响应比调度算法","children":[{"id":"e2c38aeb625f","title":"优先权=（等待时间+要求服务时间）/要求服务时间","children":[],"parent":"fd6690ea57e1"}],"parent":"3211cbd19e9a"}],"parent":"08dd641b4c91"}],"parent":"9aafba07bba7","collapsed":true},{"id":"d891d6ddca7b","title":"中级调度","children":[{"id":"c7c5faa020e7","title":"定义","children":[{"id":"e8517acefb3f","title":"调度的对象是进程，把暂时不能运行的进程放到外存，等条件成熟后又把调出去的进程调入内存","children":[],"parent":"c7c5faa020e7"}],"parent":"d891d6ddca7b"}],"parent":"9aafba07bba7"},{"id":"8894ce5d6b10","title":"低级调度（进程调度）","children":[{"id":"bbf98a84f7fe","title":"定义","children":[{"id":"17ca5d8bbcdc","title":"调度的对象是进程，根据某种算法给从就绪队列中进程分配CPU","children":[],"parent":"bbf98a84f7fe"}],"parent":"8894ce5d6b10"},{"id":"a1095d0ab3f7","title":"算法","children":[{"id":"fd438ef31b76","title":"轮转调度算法","children":[{"id":"739832a299a5","title":"就绪队列的进程每次都运行一个时间片","children":[],"parent":"fd438ef31b76"},{"id":"3a0296602bc4","title":"时间片的大小影响效率","children":[],"parent":"fd438ef31b76"}],"parent":"a1095d0ab3f7"},{"id":"90c69f491ea7","title":"优先级调度算法","children":[],"parent":"a1095d0ab3f7"},{"id":"5c6eb1616eb8","title":"多级反馈队列调度算法","children":[{"id":"20896769297b","title":"设置多个就绪队列，第一个队列优先级最高，其余队列的优先级依次降低，优先级越高的队列时间片越短","children":[],"parent":"5c6eb1616eb8"},{"id":"9ff613488ad3","title":"每个队列采用FCFS算法，如果进程在当前队列不能执行完，就把该进程放到下一个队列的末尾","children":[],"parent":"5c6eb1616eb8"},{"id":"c04a67b2c5b2","title":"队列优先级越高，越先执行","children":[],"parent":"5c6eb1616eb8"}],"parent":"a1095d0ab3f7"}],"parent":"8894ce5d6b10"},{"id":"d88cde681a7a","title":"死锁","children":[{"id":"9e55438b15c8","title":"原因","children":[{"id":"254cd795681a","title":"竞争不可抢占资源","children":[],"parent":"9e55438b15c8"},{"id":"f4c734f8a84a","title":"竞争可消耗资源","children":[],"parent":"9e55438b15c8"}],"parent":"d88cde681a7a"},{"id":"922ef21d6d60","title":"预防死锁","children":[{"id":"d723224741f1","title":"破坏“请求和保持条件”","parent":"922ef21d6d60","children":[{"id":"5cd97fd85729","title":"第一种协议","parent":"d723224741f1","children":[{"id":"b6a78a7d5221","title":"进程必须一次性申请所有资源","children":[],"parent":"5cd97fd85729"}]},{"id":"4d5bee6856d4","title":"第二种协议","parent":"d723224741f1","children":[{"id":"efa7c1aad1b2","title":"进程获得初期运行资源就可以运行，运行过程中逐步释放资源，再请求新资源","parent":"4d5bee6856d4","children":[]}]}]},{"id":"f525cd6f5a20","title":"破坏不可抢占条件","children":[{"id":"7f231df9903a","title":"当进程不能运行时，必须释放所持有的资源","children":[],"parent":"f525cd6f5a20"}],"parent":"922ef21d6d60"}],"parent":"d88cde681a7a"},{"id":"bf640786ca93","title":"避免死锁","children":[{"id":"94fda3563314","title":"安全状态","children":[{"id":"ee1c6bf452df","title":"进程能按照一定的序列顺利执行完","children":[],"parent":"94fda3563314"}],"parent":"bf640786ca93"},{"id":"16fab30889fd","title":"算法","children":[{"id":"98f04491bcc7","title":"银行家算法","children":[],"parent":"16fab30889fd"}],"parent":"bf640786ca93"}],"parent":"d88cde681a7a"}],"parent":"8894ce5d6b10","collapsed":false}],"parent":"9aafba07bba7"},{"id":"a558cc749bfd","title":"目标","children":[{"id":"b421788be9c3","title":"提供CPU利用率","children":[],"parent":"a558cc749bfd"},{"id":"979a15c8ce33","title":"CPU利用率=CPU有效工作时间/CPU有效工作时间+CPU等待时间","children":[],"parent":"a558cc749bfd"}],"parent":"9aafba07bba7"}],"parent":"root","collapsed":true},{"id":"a4c585f3e97a","title":"虚拟存储器","children":[{"id":"486fa7e34077","title":"背景","parent":"a4c585f3e97a","children":[{"id":"85cffeac5d63","title":"有的作业很大，无法一次性装入内存","parent":"486fa7e34077","children":[]},{"id":"1e6158585dd3","title":"有大量的作业要求运行，内存无法全部运行","parent":"486fa7e34077","children":[]}]},{"id":"3fea34b744d6","title":"原理","parent":"a4c585f3e97a","children":[{"id":"8c1ed815b166","title":"在较短的时间内，程序只执行一部分，只访问一段内存空间","parent":"3fea34b744d6","children":[]},{"id":"32761194e2fa","title":"时间局部性","parent":"3fea34b744d6","children":[{"id":"b731a13d5e3b","title":"被访问过的指令很可能不久之后会被再次访问","parent":"32761194e2fa","children":[]}]},{"id":"2094ad526e21","title":"空间局部性","parent":"3fea34b744d6","children":[{"id":"71891431e52e","title":"程序在一段时间里访问的地址很可能集中在一块","parent":"2094ad526e21","children":[]}]}]},{"id":"d0fd1a586beb","title":"请求分页存储管理方式","parent":"a4c585f3e97a","children":[{"id":"3d6a1c3d7c8a","title":"页面置换算法","parent":"d0fd1a586beb","children":[{"id":"92fcaa46348d","title":"最佳适应算法","parent":"3d6a1c3d7c8a","children":[{"id":"4f663b7bbf74","title":"淘汰页是以后永不用的，或许是最长时间内不用访问的页面","parent":"92fcaa46348d","children":[]},{"id":"0d7834423dff","title":"最理想的算法，无法实现","parent":"92fcaa46348d","children":[]}]},{"id":"4253472d7509","title":"先进先出置换算法","parent":"3d6a1c3d7c8a","children":[]},{"id":"a673977fa41e","title":"LRU置换算法","parent":"3d6a1c3d7c8a","children":[{"id":"aa834e27dd39","title":"淘汰最久未使用的页面","parent":"a673977fa41e","children":[]},{"id":"1ed17fb70f2e","title":"栈","parent":"a673977fa41e","children":[]},{"id":"21bd88f0f7f1","title":"需要很多硬件支持","parent":"a673977fa41e","children":[]}]},{"id":"08701fb6e452","title":"clock置换算法","parent":"3d6a1c3d7c8a","children":[{"id":"db915b6276f5","title":"基本Clock置换算法","children":[{"id":"7bb10b76722e","title":"为每一页设定一个访问位，当被访问过时置为1","children":[],"parent":"db915b6276f5"},{"id":"7c3e8ec3d32d","title":"第一次扫描，把访问位为0的页面换出去，把访问位为1的页面置为0","children":[],"parent":"db915b6276f5"},{"id":"09b45bd51c0f","title":"如果第一次扫描没有把页面换出，那就进行第二次","parent":"db915b6276f5","children":[]}],"parent":"08701fb6e452"},{"id":"642bd0708e84","title":"改进的Clock置换算法","children":[],"parent":"08701fb6e452"}]}]}]}],"parent":"root","collapsed":true},{"id":"3716f144647f","title":"文件管理","children":[],"parent":"root"}]}},"meta":{"id":"5abae125e4b007d25121500b","member":"587a097ae4b098bf4ca2ed8f","exportTime":"2018-03-29 15:59:31","diagramInfo":{"category":"mind_free","title":"操作xit","created":"2018-03-28 08:26:13","creator":"587a097ae4b098bf4ca2ed8f","modified":"2018-03-29 15:58:57"},"type":"ProcessOn Schema File","version":"1.0"}}