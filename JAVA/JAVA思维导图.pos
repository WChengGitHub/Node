{"diagram":{"image":{"height":200,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","width":200,"y":0,"x":0},"elements":{"id":"root","title":"java","leftChildren":[{"id":"788852e37325","title":"对象","children":[{"id":"b35eb37725f9","title":"定义","children":[{"id":"8aa7f78667d5","title":"java中的对象可以类比我们现实生活的对象，比如一只猫可以是对象，一个学生也是对象。","children":[],"parent":"b35eb37725f9"},{"id":"f6a5519ad576","title":"一个学生有身高，体重。对象是有属性。一个学生可以到图书馆看书，可以去饭堂吃饭。对象是有行为，也可以理解为方法。","parent":"b35eb37725f9","children":[]}],"parent":"788852e37325","collapsed":false}],"parent":"root","collapsed":true},{"id":"8a1dabfff9cc","title":"类","parent":"root","children":[{"id":"8a067715cbc4","title":"内部类","children":[{"id":"cbb56f9c5320","title":"定义","children":[{"id":"5174289e5c73","title":"一个类定义在另一个类的内部","children":[],"parent":"cbb56f9c5320"}],"parent":"8a067715cbc4"},{"id":"8a9380f0cb76","title":"应用场景","children":[{"id":"d0266bbbe92d","title":"在内部类实现接口，并返回对该类的应用，可以隐藏该接口的实现","children":[],"parent":"8a9380f0cb76"},{"id":"6f96a596be64","title":"要解决一个复杂的问题，需要一个类来辅助，但又不需要这个类公共可用","children":[],"parent":"8a9380f0cb76"}],"parent":"8a067715cbc4"},{"id":"19b2e671f374","title":"分类","parent":"8a067715cbc4","children":[{"id":"5281a51bea13","title":"匿名内部类","parent":"19b2e671f374","children":[{"id":"082b5da15bdf","title":"定义","parent":"5281a51bea13","children":[{"id":"0dafd6f60ecd","title":"该类没用名字，在函数返回处直接实现该类","parent":"082b5da15bdf","children":[]}]}]},{"id":"a4b1689b69fe","title":"嵌套类","parent":"19b2e671f374","children":[{"id":"683edc72848f","title":"定义","parent":"a4b1689b69fe","children":[{"id":"5bca60af4a26","title":"内部类的声明为static,不需要和外围类发生联系","parent":"683edc72848f","children":[]}]}]}]}],"parent":"8a1dabfff9cc"}],"collapsed":true},{"id":"6720a3f601c8","title":"数组","parent":"root","children":[{"id":"8641b5ca483d","title":"定义","parent":"6720a3f601c8","children":[{"id":"d156f84442a6","title":"在JAVA中，数组存储数据和随机访问数据的效率最好","parent":"8641b5ca483d","children":[]},{"id":"79327334c57c","title":"在Java中数组也是一种对象","parent":"8641b5ca483d","children":[]}]},{"id":"35e68850b2be","title":"功能","parent":"6720a3f601c8","children":[{"id":"be035cd56ac3","title":"复制数组","parent":"35e68850b2be","children":[]},{"id":"5383705ab6cf","title":"数组比较","parent":"35e68850b2be","children":[]},{"id":"60da7d6cf72d","title":"数组排序","parent":"35e68850b2be","children":[]},{"id":"3672c86cd0cc","title":"查找数组的元素","parent":"35e68850b2be","children":[]}]},{"id":"6e4db47be1cf","title":"使用","parent":"6720a3f601c8","children":[{"id":"d3307d136bbf","title":"声明数组，分配空间，赋值，处理","parent":"6e4db47be1cf","children":[]}]}],"collapsed":true},{"id":"7ea127fa9059","title":"I/O系统","parent":"root","children":[{"id":"a14b4aee5677","title":"核心概念","children":[{"id":"281331dc784a","title":"数据流","children":[{"id":"69cf596f5bc3","title":"一种有序的、有起点、有终点的数据序列","children":[],"parent":"281331dc784a"}],"parent":"a14b4aee5677"},{"id":"2f3462ab18de","title":"字节流","children":[{"id":"cd603e08e3b5","title":"数据流中最小的单位是字节","children":[],"parent":"2f3462ab18de"}],"parent":"a14b4aee5677"},{"id":"6e702db3170b","title":"字符流","children":[{"id":"1a008f0b2337","title":"数据流中最小单位是字符","children":[],"parent":"6e702db3170b"},{"id":"f16a86df66b1","title":"Java采用的unicode编码，一个字符两个字节","children":[],"parent":"6e702db3170b"}],"parent":"a14b4aee5677"}],"parent":"7ea127fa9059"},{"id":"c7c577bdf1e8","title":"背景","children":[{"id":"ae9d1566195b","title":"当程序需要读取数据时，就需要和数据源建立连接。数据源可以是内存，文件，网络连接等","children":[],"parent":"c7c577bdf1e8"}],"parent":"7ea127fa9059"},{"id":"11ef79c61f6c","title":"流式部分","parent":"7ea127fa9059","children":[{"id":"e356ad5a65ad","title":"字节流","children":[{"id":"db9ed3801307","title":"InputStream","children":[{"id":"87044ba9ec89","title":"FileInputStream","children":[{"id":"593c9e2785cf","title":"对文件进行读取","parent":"87044ba9ec89","children":[]}],"parent":"db9ed3801307"},{"id":"966ba82c2920","title":"ByteArrayInputStream","children":[{"id":"6870434ee54e","title":"对内存缓冲区进行读取","parent":"966ba82c2920","children":[]}],"parent":"db9ed3801307"},{"id":"0dd0116becb1","title":"StringBufferInputStream","children":[{"id":"d6eabfbb5d0a","title":"对String对象进行读取","parent":"0dd0116becb1","children":[]}],"parent":"db9ed3801307"},{"id":"f8c031d5efc2","title":"PipedInputStream","children":[{"id":"818074e2e641","title":"实现了pipe概念，只要在线程间使用","parent":"f8c031d5efc2","children":[]}],"parent":"db9ed3801307"},{"id":"886f2044a26b","title":"SequenceInputStream","parent":"db9ed3801307","children":[{"id":"19104dd4905b","title":"合并多个输入流","children":[],"parent":"886f2044a26b"}]}],"parent":"e356ad5a65ad"},{"id":"abecab35b62b","title":"OutputStream","children":[{"id":"70140a457eb5","title":"FileOutputStream","children":[],"parent":"abecab35b62b"},{"id":"1ca768e9e5e2","title":"ByteArrayOutputStream","children":[],"parent":"abecab35b62b"},{"id":"062ce2d75b54","title":"PipedOutputStream","children":[],"parent":"abecab35b62b"},{"id":"02783d0de257","title":"SequenceOutputStream","children":[],"parent":"abecab35b62b"}],"parent":"e356ad5a65ad"}],"parent":"11ef79c61f6c"},{"id":"61b436b85339","title":"字符流","children":[{"id":"07f429b9da34","title":"Reader","children":[{"id":"0a5bb1ed5345","title":"FileReader","children":[],"parent":"07f429b9da34"},{"id":"c6fd761f48ef","title":"StringReader","children":[],"parent":"07f429b9da34"},{"id":"e09d5c4f9ecc","title":"PipedReader","children":[],"parent":"07f429b9da34"},{"id":"fc28bae4cde1","title":"CharArrayReader","children":[],"parent":"07f429b9da34"},{"id":"7c33ac01d333","title":"InputStreamReader","children":[],"parent":"07f429b9da34"}],"parent":"61b436b85339"},{"id":"5f6ad667960c","title":"Writer","children":[{"id":"71c89cbe7f0d","title":"FileWriter","children":[],"parent":"5f6ad667960c"},{"id":"c59c72de2216","title":"StringWriter","children":[],"parent":"5f6ad667960c"},{"id":"400229568cef","title":"PipedWriter","children":[],"parent":"5f6ad667960c"},{"id":"983edfbc6bc5","title":"CharArrayWriter","children":[],"parent":"5f6ad667960c"},{"id":"b35ced652795","title":"OutputStreamWriter","children":[],"parent":"5f6ad667960c"}],"parent":"61b436b85339"}],"parent":"11ef79c61f6c"}]},{"id":"5b3713fef412","title":"非流式部分","parent":"7ea127fa9059","children":[]},{"id":"59b60aee825a","title":"其他","children":[],"parent":"7ea127fa9059"},{"id":"8ded46745cf2","title":"使用","parent":"7ea127fa9059","children":[{"id":"60aafec26f47","title":"使用步骤","parent":"8ded46745cf2","children":[{"id":"3e106dc1eaf0","title":"确定输入设备","children":[{"id":"7ae600b4dcbc","title":"文件","children":[{"id":"9f7f9817af96","title":"读","children":[{"id":"b7aa423d22b4","title":"FileInputStream,FileReader","children":[],"parent":"9f7f9817af96"}],"parent":"7ae600b4dcbc"},{"id":"d19dcd1e47c7","title":"写","children":[{"id":"c341b5738ae8","title":"FileOutputStream,FileWriter","children":[],"parent":"d19dcd1e47c7"}],"parent":"7ae600b4dcbc"}],"parent":"3e106dc1eaf0"},{"id":"2c16495dcb7b","title":"数组","children":[{"id":"3325419e6633","title":"读","children":[{"id":"5f0a50eabfdc","title":"ByteArrayInputStream, ByteArrayOutputStream","parent":"3325419e6633","children":[]}],"parent":"2c16495dcb7b"},{"id":"619988579dfd","title":"写","parent":"2c16495dcb7b","children":[{"id":"2b252eed4aa5","title":"CharArrayReader, CharArrayWriter","parent":"619988579dfd","children":[]}]}],"parent":"3e106dc1eaf0"},{"id":"85165fa6cfb8","title":"String","children":[{"id":"68a95b87c32d","title":"读","parent":"85165fa6cfb8","children":[{"id":"67d929a417c8","title":"StringReader","parent":"68a95b87c32d","children":[]}]},{"id":"3bd5c36ca2c7","title":"写","parent":"85165fa6cfb8","children":[{"id":"a0ff4defc2f6","title":"StringWriter","children":[],"parent":"3bd5c36ca2c7"}]}],"parent":"3e106dc1eaf0"},{"id":"4f4cb23446f5","title":"Socket流","children":[{"id":"75d7fc98cf6e","title":"读","parent":"4f4cb23446f5","children":[{"id":"4dc56ffaee5a","title":"System.in(键盘输入）","parent":"75d7fc98cf6e","children":[]}]},{"id":"10344cdcc2e8","title":"写","parent":"4f4cb23446f5","children":[{"id":"048543fdaa4a","title":"System.out(显示器显示）","children":[],"parent":"10344cdcc2e8"}]}],"parent":"3e106dc1eaf0"}],"parent":"60aafec26f47","collapsed":true},{"id":"5c9410e96c7e","title":"是否需要转换流","parent":"60aafec26f47","children":[{"id":"7850ad8cd316","title":"Stream转化为Reader、Writer：InputStreamReader，OutputStreamWriter","parent":"5c9410e96c7e","children":[]}],"collapsed":true},{"id":"c8a6fa2bbc84","title":"是否需要缓冲提高效率","children":[{"id":"17591a9ac41f","title":"BufferedInputStream、BufferedReader、BufferedOutputStream、BufferedWriter","children":[],"parent":"c8a6fa2bbc84"}],"parent":"60aafec26f47"}]},{"id":"1c74a9701dc8","title":"常用方法","parent":"8ded46745cf2","children":[{"id":"1073a250c829","title":"read","parent":"1c74a9701dc8","children":[]},{"id":"449c3e21b15a","title":"close","parent":"1c74a9701dc8","children":[]},{"id":"843dc6adc0fc","title":"write","parent":"1c74a9701dc8","children":[]},{"id":"028b5a8dc742","title":"flush","parent":"1c74a9701dc8","children":[{"id":"ff767d31f0f0","title":"把数据缓冲区的内容输出，并且清空缓冲区","parent":"028b5a8dc742","children":[]}]},{"id":"ad5cc8542614","title":"close","parent":"1c74a9701dc8","children":[]}]}]}]},{"id":"36f1f275f0a7","title":"并发","parent":"root","children":[]},{"id":"e28a2717ba1a","title":"泛型","parent":"root","children":[]}],"structure":"mind_free","root":true,"theme":"paper","children":[{"id":"a9cc294390de","title":"多态","parent":"root","children":[{"id":"0750f8ecabd3","title":"定义","parent":"a9cc294390de","children":[{"id":"6130616d0f9e","title":"对于父类发出的消息，不同的子类有不同的响应","parent":"0750f8ecabd3","children":[]}],"collapsed":false},{"id":"476b94652b69","title":"实现","parent":"a9cc294390de","children":[{"id":"e4597f226f6d","title":"基于继承方式实现","parent":"476b94652b69","children":[{"id":"ea647ff0dd7b","title":"子类重写父类继承的方法，子类向上转型为父类引用，父类引用就可以调用子类重写的方法","parent":"e4597f226f6d","children":[]}]},{"id":"aa0cf2964f59","title":"基于接口方式实现","parent":"476b94652b69","children":[{"id":"0d7815a87434","title":"类实现接口，类向上转型为接口类型，接口类型就可以调用被实现的方法","parent":"aa0cf2964f59","children":[]}]}],"collapsed":false}],"collapsed":true},{"id":"8353f540dc2c","title":"封装","parent":"root","children":[{"id":"fe13be26158b","title":"定义","parent":"8353f540dc2c","children":[{"id":"f4b4fa37757c","title":"对类的数据和方法进行限制，外部类不能随随便便得使用，需要使用定义类提供的外部接口","parent":"fe13be26158b","children":[]}]},{"id":"dadc2af068d2","title":"作用","children":[{"id":"63272b2120c0","title":"类的开发者可以很方便得修改自己的类，只要不改变外部接口的参数就不需要修改使用该类的客户端代码","parent":"dadc2af068d2","children":[]}],"parent":"8353f540dc2c"},{"id":"49872cd54025","title":"实现","children":[{"id":"7b07d01070a6","title":"根据需要把类的属性或方法定义为private,protect类型，把外部接口定义为public类型供外部使用","children":[{"id":"092e848eeaa8","title":"private","parent":"7b07d01070a6","children":[{"id":"c6cf76f5b701","title":"只有在定义类内才能使用","parent":"092e848eeaa8","children":[]}]},{"id":"88f5cae71627","title":"protected","children":[{"id":"dfc64dcc2bb9","title":"可以在本类，子类，同一个package的类使用，不同的package类不能使用","parent":"88f5cae71627","children":[]}],"parent":"7b07d01070a6"},{"id":"c60179408581","title":"public","children":[{"id":"b6ebb98fa1bf","title":"可以在任意地方使用","parent":"c60179408581","children":[]}],"parent":"7b07d01070a6"}],"parent":"49872cd54025"}],"parent":"8353f540dc2c"}],"collapsed":true},{"id":"69bd992586ec","title":"继承","parent":"root","children":[{"id":"5399df2206fe","title":"定义","children":[{"id":"1f82e6d90aa7","title":"一个类继承了父类中所有的方法和属性","children":[],"parent":"5399df2206fe"}],"parent":"69bd992586ec"},{"id":"fdd304d975ee","title":"作用","parent":"69bd992586ec","children":[{"id":"e74b646a4fbe","title":"实现代码复用，父类抽取子类中共有的方法和属性","parent":"fdd304d975ee","children":[]}]},{"id":"722678602f0d","title":"实现","parent":"69bd992586ec","children":[{"id":"90879c047664","title":"使用extends关键字","parent":"722678602f0d","children":[]},{"id":"b3023bfbd884","title":"子类根据需要重写父类的方法或者添加新的属性或方法","parent":"722678602f0d","children":[]}]},{"id":"c163cbecb401","title":"缺点","children":[{"id":"51581cd67323","title":"父类变，子类一定变","children":[],"parent":"c163cbecb401"},{"id":"e850bf85813b","title":"破坏了封装，父类的属性或方法对子类可见","parent":"c163cbecb401","children":[]},{"id":"149458cd5e84","title":"继承是一种强耦合关系","parent":"c163cbecb401","children":[]}],"parent":"69bd992586ec"},{"id":"f367fb5806d0","title":"使用建议","children":[{"id":"829f4eadcf6d","title":"如果子类需要向上转型为父类，就一定得用继承","children":[],"parent":"f367fb5806d0"},{"id":"c9d67fd885f0","title":"尽量少用继承","children":[],"parent":"f367fb5806d0"},{"id":"011f76ab137b","title":"如果只是为了代码复用，尽量不要用继承","children":[],"parent":"f367fb5806d0"}],"parent":"69bd992586ec"}],"collapsed":true},{"id":"58a723a419fc","title":"接口","parent":"root","children":[{"id":"154d5ae1530d","title":"定义","children":[{"id":"51f5dc9ff68e","title":"接口是一种比抽象类更抽象的类，没有具体实现","children":[],"parent":"154d5ae1530d"},{"id":"1f5eb2cd0a53","title":"接口定义了类与类的协议，任何实现该接口的类都像这样","children":[],"parent":"154d5ae1530d"}],"parent":"58a723a419fc"},{"id":"a9261438eb1d","title":"作用","children":[{"id":"d6b1265e9cb4","title":"java中没有多重继承，可以用接口来实现类似多层继承的特性","children":[],"parent":"a9261438eb1d"},{"id":"781181cdd7d7","title":"把接口当成参数，任何实现该接口的类都可以当成该接口的参数","children":[],"parent":"a9261438eb1d"}],"parent":"58a723a419fc"},{"id":"e28348b96302","title":"实现","children":[{"id":"8c5643d8fc25","title":"使用implements关键字","children":[],"parent":"e28348b96302"},{"id":"9642e16b7803","title":"根据需要重写方法","children":[],"parent":"e28348b96302"}],"parent":"58a723a419fc"},{"id":"16b5b12899fe","title":"建议","children":[{"id":"fb78910127d2","title":"优先选择类而不是接口","children":[],"parent":"16b5b12899fe"},{"id":"7a4be9b56f48","title":"接口是一种重要工具，但是它们容易被滥用","children":[],"parent":"16b5b12899fe"}],"parent":"58a723a419fc"}],"collapsed":true},{"id":"1974991fe221","title":"容器","parent":"root","children":[{"id":"cf575d32c29b","title":"Set","children":[{"id":"e2ac1b69eb0d","title":"定义","children":[{"id":"f482e3847dbb","title":"不包含重复元素，是一个无序集合","children":[],"parent":"e2ac1b69eb0d"}],"parent":"cf575d32c29b"},{"id":"a1861683c192","title":"分类","parent":"cf575d32c29b","children":[{"id":"dc12846f0fad","title":"HashSet","parent":"a1861683c192","children":[{"id":"4d413b5ed3f9","title":"定义","parent":"dc12846f0fad","children":[{"id":"d0d60b003d22","title":"HashSet不保证元素的插入顺序","children":[],"parent":"4d413b5ed3f9"},{"id":"2554210da757","title":"基于散列表实现，存取的时间效率比较高，但空间效率比较低","parent":"4d413b5ed3f9","children":[]}]}]},{"id":"6289f16a581b","title":"TreeSet","parent":"a1861683c192","children":[{"id":"daed8ca16184","title":"定义","children":[{"id":"c9f1ffe2cf20","title":"保证元素的顺序","children":[],"parent":"daed8ca16184"},{"id":"310ec5069ba9","title":"支持自然排序和默认排序","children":[],"parent":"daed8ca16184"},{"id":"59f74e8ef9fd","title":"基于树结构实现，遍历和访问比较快","children":[],"parent":"daed8ca16184"}],"parent":"6289f16a581b"}]},{"id":"b1e5bd96f9b2","title":"LinkdedHaseSet","parent":"a1861683c192","children":[{"id":"45452353c286","title":"定义","parent":"b1e5bd96f9b2","children":[{"id":"64c21cd152e8","title":"保证元素的顺序","parent":"45452353c286","children":[]},{"id":"098b8b686b65","title":"访问性能比HashSet好，但插入时比HashSet的效率低","parent":"45452353c286","children":[]}]}]}]}],"parent":"1974991fe221"},{"id":"45fa0d62485f","title":"List","children":[{"id":"332adbd38336","title":"定义","parent":"45fa0d62485f","children":[{"id":"bc59673e445d","title":"list继承collection,是一个有序集合","parent":"332adbd38336","children":[]}]},{"id":"110910d5a244","title":"分类","parent":"45fa0d62485f","children":[{"id":"c5c8bce80132","title":"ArrayList","children":[{"id":"d9ba81822f91","title":"定义","parent":"c5c8bce80132","children":[{"id":"8e38575f2290","title":"基于数组实现，可以动态增长","parent":"d9ba81822f91","children":[]}]},{"id":"b491f516efca","title":"应用场景","parent":"c5c8bce80132","children":[{"id":"2032c16ef350","title":"适合应用于对插入速度要求不高，但是对数据的访问速度要求比较高","parent":"b491f516efca","children":[]}]}],"parent":"110910d5a244"},{"id":"1a56649d34a7","title":"LinkedList","children":[{"id":"09f0468fdd48","title":"定义","parent":"1a56649d34a7","children":[{"id":"bb4964568ca1","title":"基于链表实现，是一个双向循环链表，可当成栈来使用","parent":"09f0468fdd48","children":[]}]},{"id":"5ef80ef68307","title":"应用场景","children":[{"id":"7ad25aa86c28","title":"适合于对访问元素的速度要求不高，但对数据的插入和删除的速度比较高","children":[],"parent":"5ef80ef68307"}],"parent":"1a56649d34a7"}],"parent":"110910d5a244"},{"id":"168c9305c407","title":"Vector","children":[{"id":"42e71cfebbc9","title":"定义","children":[{"id":"532af0632525","title":"基于数组实现，线程安全","children":[],"parent":"42e71cfebbc9"}],"parent":"168c9305c407"},{"id":"454e2a8e8257","title":"应用场景","parent":"168c9305c407","children":[{"id":"85e096ddd1ad","title":"适合多线程访问元素","parent":"454e2a8e8257","children":[]}]}],"parent":"110910d5a244"},{"id":"761a3a8dc742","title":"Stack","children":[{"id":"08cb9161f439","title":"定义","parent":"761a3a8dc742","children":[{"id":"901a4c8b9551","title":"基于栈的实现方式，后进先出","parent":"08cb9161f439","children":[]}]},{"id":"31d33bf0d976","title":"应用场景","children":[{"id":"8fb932e2784b","title":"适合于要求元素后进先出","children":[],"parent":"31d33bf0d976"}],"parent":"761a3a8dc742"}],"parent":"110910d5a244"}],"collapsed":false}],"parent":"1974991fe221"},{"id":"99e1494d0aba","title":"Queue","children":[{"id":"48ff778f3c66","title":"阻塞队列","children":[{"id":"8791059fc957","title":"定义","children":[{"id":"9c30dcf2f0e6","title":"当队列中的元素为空时，取元素的线程被阻塞。当队列的元素为满时，往队列添加元素的线程被阻塞","children":[],"parent":"8791059fc957"}],"parent":"48ff778f3c66"},{"id":"0a3366e7d88d","title":"优点","children":[{"id":"a7b96f3fbbc8","title":"自动唤醒被阻塞的线程，不需要像非阻塞队列那样需要考虑线程同步策略和线程唤醒策略","children":[],"parent":"0a3366e7d88d"}],"parent":"48ff778f3c66"},{"id":"fe9d73813ad1","title":"分类","children":[{"id":"7060759f2dd3","title":"ArrayBlockQueue","children":[{"id":"fef317892874","title":"定义","parent":"7060759f2dd3","children":[{"id":"187a654205a2","title":"基于数组实现","parent":"fef317892874","children":[]}]},{"id":"eb0bbab01b05","title":"使用","children":[{"id":"19694e33ea13","title":"需要指定容器的长度","children":[],"parent":"eb0bbab01b05"},{"id":"8311571475c8","title":"需要指定公平性和非公平性，默认为不公平性，不保证被阻塞时间最长的线程被唤醒","children":[],"parent":"eb0bbab01b05"}],"parent":"7060759f2dd3"}],"parent":"fe9d73813ad1","collapsed":false},{"id":"6eae0e6ad886","title":"LinkedBlockQueue","parent":"fe9d73813ad1","children":[{"id":"68e2e9d6a07d","title":"定义","parent":"6eae0e6ad886","children":[{"id":"41f20c188cad","title":"基于链表实现，可以不指定长度","parent":"68e2e9d6a07d","children":[]}]}]},{"id":"310c41a3903a","title":"PriorityBlockQueue","parent":"fe9d73813ad1","children":[{"id":"588d4880e9eb","title":"定义","parent":"310c41a3903a","children":[{"id":"22e480bb11f7","title":"每次出队的元素都是优先级最高的元素","parent":"588d4880e9eb","children":[]}]}]},{"id":"53fb32a33471","title":"DelayBlockQueue","parent":"fe9d73813ad1","children":[{"id":"23f53ca7cf3a","title":"定义","parent":"53fb32a33471","children":[{"id":"29d7a0663546","title":"只要到了一定的时间后才能取元素","parent":"23f53ca7cf3a","children":[]}]}]}],"parent":"48ff778f3c66"}],"parent":"99e1494d0aba"},{"id":"0265b8310c58","title":"非阻塞队列","children":[{"id":"244dbc70c2b8","title":"定义","children":[{"id":"db82eeb87d89","title":"是一种先进先出模型，有数组和链表两种实现方式","children":[],"parent":"244dbc70c2b8"}],"parent":"0265b8310c58"},{"id":"278e1cda3f9d","title":"分类","children":[{"id":"0eb5d992a68c","title":"LinkedList","children":[],"parent":"278e1cda3f9d"},{"id":"1b3037ae474c","title":"ArrayDeque","children":[],"parent":"278e1cda3f9d"}],"parent":"0265b8310c58"}],"parent":"99e1494d0aba"}],"parent":"1974991fe221"},{"id":"67fea938b1d7","title":"Map","children":[{"id":"e8a4a3de02e7","title":"定义","children":[{"id":"ea65b03f986e","title":"集合中的每个元素都包含键对象和值对像，键对象不能重复","children":[],"parent":"e8a4a3de02e7"}],"parent":"67fea938b1d7"},{"id":"e7e7a47d3de0","title":"分类","children":[{"id":"18fe374aea8f","title":"HashMap","children":[{"id":"60ba0c235700","title":"定义","children":[{"id":"afe2507b61d2","title":"不保证元素的有序性，查询效率比较高","children":[],"parent":"60ba0c235700"}],"parent":"18fe374aea8f"}],"parent":"e7e7a47d3de0"},{"id":"72238a8be48a","title":"LinkedHashMap","children":[{"id":"35bda8810eda","title":"定义","children":[{"id":"d67ac3434c6d","title":"基于双向链表实现，保证元素的顺序","children":[],"parent":"35bda8810eda"}],"parent":"72238a8be48a"}],"parent":"e7e7a47d3de0"},{"id":"95773eb3ec83","title":"TreeMap","children":[{"id":"767c4301b317","title":"定义","children":[{"id":"aa3a02b923d3","title":"基于红黑树实现，插入时可进行排序","children":[],"parent":"767c4301b317"}],"parent":"95773eb3ec83"}],"parent":"e7e7a47d3de0"}],"parent":"67fea938b1d7"}],"parent":"1974991fe221"}],"collapsed":true},{"id":"ad7d78b6b4a4","title":"字符串","parent":"root","children":[{"id":"360a1b3a730d","title":"String","parent":"ad7d78b6b4a4","children":[{"id":"8b7b676d81c8","title":"定义","parent":"360a1b3a730d","children":[{"id":"f01b7133dcf9","title":"String是一个对象，并且是不变的，每一次对String的改变实际上是返回一个新的String对象","parent":"8b7b676d81c8","children":[]}]},{"id":"a72120b5cc0b","title":"相关","children":[{"id":"a092c3fc4e5e","title":"每一次我们创建字符串，实际是先系统查看字符串符是否有该字符串。如果有，就返回该字符串的引用。否则，就在字符串池中创建一个新字符串，并返回引用","children":[],"parent":"a72120b5cc0b"},{"id":"fadecd5b0cd8","title":"Stirng的+操作的实质是编译器自动创建StringBuilder对象，并调用StringBuffer对象的append()方法添加字符串。编译器会为每一个String对象创建一个StringBuilder对象","children":[],"parent":"a72120b5cc0b"}],"parent":"360a1b3a730d"},{"id":"3af68d5ab8fe","title":"功能","children":[{"id":"9540dd79641a","title":"字符串比较","children":[],"parent":"3af68d5ab8fe"},{"id":"953f426e4f01","title":"字符串查找","children":[],"parent":"3af68d5ab8fe"},{"id":"2df5191d7258","title":"字符串截取","children":[],"parent":"3af68d5ab8fe"},{"id":"4f7b24c497cb","title":"字符串替换","children":[],"parent":"3af68d5ab8fe"}],"parent":"360a1b3a730d"}]},{"id":"a9587cc8d092","title":"StringBuilder","parent":"ad7d78b6b4a4","children":[{"id":"d60b1998aad9","title":"定义","parent":"a9587cc8d092","children":[{"id":"48ebd0979b22","title":"类似于StringBuffer,不过它不是线程安全，性能相对比StringBuffer快","parent":"d60b1998aad9","children":[]}]},{"id":"6ed2368bd52e","title":"应用场景","parent":"a9587cc8d092","children":[{"id":"ff5d2cdf83bf","title":"频繁进行字符串的元素（追加，删除，修改等）","parent":"6ed2368bd52e","children":[]}]},{"id":"1862fa277e72","title":"功能","children":[{"id":"bc341cfdd2fb","title":"类似于StringBuffer","children":[],"parent":"1862fa277e72"}],"parent":"a9587cc8d092"}]},{"id":"4f0cdcc7ffe3","title":"StringBuffer","parent":"ad7d78b6b4a4","children":[{"id":"5772cc9abde8","title":"定义","children":[{"id":"96609f6b4914","title":"StringBuffer类似于String,不过StringBuffer是可变的，每一次对StringBuffer的修改实际上就是对StringBuffer对象的修改","children":[],"parent":"5772cc9abde8"},{"id":"aa11a3c80025","title":"StringBuffer是线程安全的","parent":"5772cc9abde8","children":[]}],"parent":"4f0cdcc7ffe3"},{"id":"6428786bd5fe","title":"应用场景","parent":"4f0cdcc7ffe3","children":[{"id":"3e781454aa9f","title":"适合于对字符串的修改，删除等，即侧重于对字符串的改变","parent":"6428786bd5fe","children":[]}]},{"id":"1ebea3b72064","title":"功能","parent":"4f0cdcc7ffe3","children":[{"id":"1f0b5a82be68","title":"许多方法和String提供的方法差不多","parent":"1ebea3b72064","children":[]},{"id":"5c59ecce9ea5","title":"它自己提供了append,delete,insert","children":[],"parent":"1ebea3b72064"}]}]}],"collapsed":true}],"lines":{}}},"meta":{"id":"5aa33727e4b0fb5a6bef100a","member":"587a097ae4b098bf4ca2ed8f","exportTime":"2018-04-08 15:00:54","diagramInfo":{"category":"mind_free","title":"JAVA","created":"2018-03-10 09:38:47","creator":"587a097ae4b098bf4ca2ed8f","modified":"2018-04-08 14:59:32"},"type":"ProcessOn Schema File","version":"1.0"}}