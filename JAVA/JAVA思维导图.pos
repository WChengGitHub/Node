{"diagram":{"image":{"height":200,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","width":200,"y":0,"x":0},"elements":{"id":"root","structure":"mind_free","leftChildren":[{"id":"788852e37325","title":"对象","parent":"root","children":[{"id":"b35eb37725f9","title":"定义","parent":"788852e37325","children":[{"id":"8aa7f78667d5","title":"java中的对象可以类比我们现实生活的对象，比如一只猫可以是对象，一个学生也是对象。","parent":"b35eb37725f9","children":[]},{"id":"f6a5519ad576","title":"一个学生有身高，体重。对象是有属性。一个学生可以到图书馆看书，可以去饭堂吃饭。对象是有行为，也可以理解为方法。","children":[],"parent":"b35eb37725f9"}],"collapsed":false}],"collapsed":true},{"id":"8a1dabfff9cc","title":"类","children":[{"id":"8a067715cbc4","title":"内部类","parent":"8a1dabfff9cc","children":[{"id":"cbb56f9c5320","title":"定义","parent":"8a067715cbc4","children":[{"id":"5174289e5c73","title":"一个类定义在另一个类的内部","parent":"cbb56f9c5320","children":[]}]},{"id":"8a9380f0cb76","title":"应用场景","parent":"8a067715cbc4","children":[{"id":"d0266bbbe92d","title":"在内部类实现接口，并返回对该类的应用，可以隐藏该接口的实现","parent":"8a9380f0cb76","children":[]},{"id":"6f96a596be64","title":"要解决一个复杂的问题，需要一个类来辅助，但又不需要这个类公共可用","parent":"8a9380f0cb76","children":[]}]},{"id":"19b2e671f374","title":"分类","children":[{"id":"5281a51bea13","title":"匿名内部类","children":[{"id":"082b5da15bdf","title":"定义","children":[{"id":"0dafd6f60ecd","title":"该类没用名字，在函数返回处直接实现该类","children":[],"parent":"082b5da15bdf"}],"parent":"5281a51bea13"}],"parent":"19b2e671f374"},{"id":"a4b1689b69fe","title":"嵌套类","children":[{"id":"683edc72848f","title":"定义","children":[{"id":"5bca60af4a26","title":"内部类的声明为static,不需要和外围类发生联系","children":[],"parent":"683edc72848f"}],"parent":"a4b1689b69fe"}],"parent":"19b2e671f374"}],"parent":"8a067715cbc4"}]}],"parent":"root","collapsed":true},{"id":"6720a3f601c8","title":"数组","children":[],"parent":"root"},{"id":"7ea127fa9059","title":"I/O系统","children":[],"parent":"root"},{"id":"36f1f275f0a7","title":"并发","children":[],"parent":"root"},{"id":"e28a2717ba1a","title":"泛型","children":[],"parent":"root"}],"title":"java","root":true,"theme":"paper","children":[{"id":"a9cc294390de","title":"多态","children":[{"id":"0750f8ecabd3","title":"定义","children":[{"id":"6130616d0f9e","title":"对于父类发出的消息，不同的子类有不同的响应","children":[],"parent":"0750f8ecabd3"}],"parent":"a9cc294390de","collapsed":false},{"id":"476b94652b69","title":"实现","children":[{"id":"e4597f226f6d","title":"基于继承方式实现","children":[{"id":"ea647ff0dd7b","title":"子类重写父类继承的方法，子类向上转型为父类引用，父类引用就可以调用子类重写的方法","children":[],"parent":"e4597f226f6d"}],"parent":"476b94652b69"},{"id":"aa0cf2964f59","title":"基于接口方式实现","children":[{"id":"0d7815a87434","title":"类实现接口，类向上转型为接口类型，接口类型就可以调用被实现的方法","children":[],"parent":"aa0cf2964f59"}],"parent":"476b94652b69"}],"parent":"a9cc294390de","collapsed":false}],"parent":"root","collapsed":false},{"id":"8353f540dc2c","title":"封装","children":[{"id":"fe13be26158b","title":"定义","children":[{"id":"f4b4fa37757c","title":"对类的数据和方法进行限制，外部类不能随随便便得使用，需要使用定义类提供的外部接口","children":[],"parent":"fe13be26158b"}],"parent":"8353f540dc2c"},{"id":"dadc2af068d2","title":"作用","parent":"8353f540dc2c","children":[{"id":"63272b2120c0","title":"类的开发者可以很方便得修改自己的类，只要不改变外部接口的参数就不需要修改使用该类的客户端代码","children":[],"parent":"dadc2af068d2"}]},{"id":"49872cd54025","title":"实现","parent":"8353f540dc2c","children":[{"id":"7b07d01070a6","title":"根据需要把类的属性或方法定义为private,protect类型，把外部接口定义为public类型供外部使用","parent":"49872cd54025","children":[{"id":"092e848eeaa8","title":"private","children":[{"id":"c6cf76f5b701","title":"只有在定义类内才能使用","children":[],"parent":"092e848eeaa8"}],"parent":"7b07d01070a6"},{"id":"88f5cae71627","title":"protected","parent":"7b07d01070a6","children":[{"id":"dfc64dcc2bb9","title":"可以在本类，子类，同一个package的类使用，不同的package类不能使用","children":[],"parent":"88f5cae71627"}]},{"id":"c60179408581","title":"public","parent":"7b07d01070a6","children":[{"id":"b6ebb98fa1bf","title":"可以在任意地方使用","children":[],"parent":"c60179408581"}]}]}]}],"parent":"root","collapsed":true},{"id":"69bd992586ec","title":"继承","children":[{"id":"5399df2206fe","title":"定义","parent":"69bd992586ec","children":[{"id":"1f82e6d90aa7","title":"一个类继承了父类中所有的方法和属性","parent":"5399df2206fe","children":[]}]},{"id":"fdd304d975ee","title":"作用","children":[{"id":"e74b646a4fbe","title":"实现代码复用，父类抽取子类中共有的方法和属性","children":[],"parent":"fdd304d975ee"}],"parent":"69bd992586ec"},{"id":"722678602f0d","title":"实现","children":[{"id":"90879c047664","title":"使用extends关键字","children":[],"parent":"722678602f0d"},{"id":"b3023bfbd884","title":"子类根据需要重写父类的方法或者添加新的属性或方法","children":[],"parent":"722678602f0d"}],"parent":"69bd992586ec"},{"id":"c163cbecb401","title":"缺点","parent":"69bd992586ec","children":[{"id":"51581cd67323","title":"父类变，子类一定变","parent":"c163cbecb401","children":[]},{"id":"e850bf85813b","title":"破坏了封装，父类的属性或方法对子类可见","children":[],"parent":"c163cbecb401"},{"id":"149458cd5e84","title":"继承是一种强耦合关系","children":[],"parent":"c163cbecb401"}]},{"id":"f367fb5806d0","title":"使用建议","parent":"69bd992586ec","children":[{"id":"829f4eadcf6d","title":"如果子类需要向上转型为父类，就一定得用继承","parent":"f367fb5806d0","children":[]},{"id":"c9d67fd885f0","title":"尽量少用继承","parent":"f367fb5806d0","children":[]},{"id":"011f76ab137b","title":"如果只是为了代码复用，尽量不要用继承","parent":"f367fb5806d0","children":[]}]}],"parent":"root","collapsed":true},{"id":"58a723a419fc","title":"接口","children":[{"id":"154d5ae1530d","title":"定义","parent":"58a723a419fc","children":[{"id":"51f5dc9ff68e","title":"接口是一种比抽象类更抽象的类，没有具体实现","parent":"154d5ae1530d","children":[]},{"id":"1f5eb2cd0a53","title":"接口定义了类与类的协议，任何实现该接口的类都像这样","parent":"154d5ae1530d","children":[]}]},{"id":"a9261438eb1d","title":"作用","parent":"58a723a419fc","children":[{"id":"d6b1265e9cb4","title":"java中没有多重继承，可以用接口来实现类似多层继承的特性","parent":"a9261438eb1d","children":[]},{"id":"781181cdd7d7","title":"把接口当成参数，任何实现该接口的类都可以当成该接口的参数","parent":"a9261438eb1d","children":[]}]},{"id":"e28348b96302","title":"实现","parent":"58a723a419fc","children":[{"id":"8c5643d8fc25","title":"使用implements关键字","parent":"e28348b96302","children":[]},{"id":"9642e16b7803","title":"根据需要重写方法","parent":"e28348b96302","children":[]}]},{"id":"16b5b12899fe","title":"建议","parent":"58a723a419fc","children":[{"id":"fb78910127d2","title":"优先选择类而不是接口","parent":"16b5b12899fe","children":[]},{"id":"7a4be9b56f48","title":"接口是一种重要工具，但是它们容易被滥用","parent":"16b5b12899fe","children":[]}]}],"parent":"root","collapsed":true},{"id":"1974991fe221","title":"容器","children":[{"id":"cf575d32c29b","title":"Set","parent":"1974991fe221","children":[{"id":"e2ac1b69eb0d","title":"定义","parent":"cf575d32c29b","children":[{"id":"f482e3847dbb","title":"不包含重复元素，是一个无序集合","parent":"e2ac1b69eb0d","children":[]}]},{"id":"a1861683c192","title":"分类","children":[{"id":"dc12846f0fad","title":"HashSet","children":[{"id":"4d413b5ed3f9","title":"定义","children":[{"id":"d0d60b003d22","title":"HashSet不保证元素的插入顺序","parent":"4d413b5ed3f9","children":[]},{"id":"2554210da757","title":"基于散列表实现，存取的时间效率比较高，但空间效率比较低","children":[],"parent":"4d413b5ed3f9"}],"parent":"dc12846f0fad"}],"parent":"a1861683c192"},{"id":"6289f16a581b","title":"TreeSet","children":[{"id":"daed8ca16184","title":"定义","parent":"6289f16a581b","children":[{"id":"c9f1ffe2cf20","title":"保证元素的顺序","parent":"daed8ca16184","children":[]},{"id":"310ec5069ba9","title":"支持自然排序和默认排序","parent":"daed8ca16184","children":[]},{"id":"59f74e8ef9fd","title":"基于树结构实现，遍历和访问比较快","parent":"daed8ca16184","children":[]}]}],"parent":"a1861683c192"},{"id":"b1e5bd96f9b2","title":"LinkdedHaseSet","children":[{"id":"45452353c286","title":"定义","children":[{"id":"64c21cd152e8","title":"保证元素的顺序","children":[],"parent":"45452353c286"},{"id":"098b8b686b65","title":"访问性能比HashSet好，但插入时比HashSet的效率低","children":[],"parent":"45452353c286"}],"parent":"b1e5bd96f9b2"}],"parent":"a1861683c192"}],"parent":"cf575d32c29b"}]},{"id":"45fa0d62485f","title":"List","parent":"1974991fe221","children":[{"id":"332adbd38336","title":"定义","children":[{"id":"bc59673e445d","title":"list继承collection,是一个有序集合","children":[],"parent":"332adbd38336"}],"parent":"45fa0d62485f"},{"id":"110910d5a244","title":"分类","children":[{"id":"c5c8bce80132","title":"ArrayList","parent":"110910d5a244","children":[{"id":"d9ba81822f91","title":"定义","children":[{"id":"8e38575f2290","title":"基于数组实现，可以动态增长","children":[],"parent":"d9ba81822f91"}],"parent":"c5c8bce80132"},{"id":"b491f516efca","title":"应用场景","children":[{"id":"2032c16ef350","title":"适合应用于对插入速度要求不高，但是对数据的访问速度要求比较高","children":[],"parent":"b491f516efca"}],"parent":"c5c8bce80132"}]},{"id":"1a56649d34a7","title":"LinkedList","parent":"110910d5a244","children":[{"id":"09f0468fdd48","title":"定义","children":[{"id":"bb4964568ca1","title":"基于链表实现，是一个双向循环链表，可当成栈来使用","children":[],"parent":"09f0468fdd48"}],"parent":"1a56649d34a7"},{"id":"5ef80ef68307","title":"应用场景","parent":"1a56649d34a7","children":[{"id":"7ad25aa86c28","title":"适合于对访问元素的速度要求不高，但对数据的插入和删除的速度比较高","parent":"5ef80ef68307","children":[]}]}]},{"id":"168c9305c407","title":"Vector","parent":"110910d5a244","children":[{"id":"42e71cfebbc9","title":"定义","parent":"168c9305c407","children":[{"id":"532af0632525","title":"基于数组实现，线程安全","parent":"42e71cfebbc9","children":[]}]},{"id":"454e2a8e8257","title":"应用场景","children":[{"id":"85e096ddd1ad","title":"适合多线程访问元素","children":[],"parent":"454e2a8e8257"}],"parent":"168c9305c407"}]},{"id":"761a3a8dc742","title":"Stack","parent":"110910d5a244","children":[{"id":"08cb9161f439","title":"定义","children":[{"id":"901a4c8b9551","title":"基于栈的实现方式，后进先出","children":[],"parent":"08cb9161f439"}],"parent":"761a3a8dc742"},{"id":"31d33bf0d976","title":"应用场景","parent":"761a3a8dc742","children":[{"id":"8fb932e2784b","title":"适合于要求元素后进先出","parent":"31d33bf0d976","children":[]}]}]}],"parent":"45fa0d62485f","collapsed":false}]},{"id":"99e1494d0aba","title":"Queue","parent":"1974991fe221","children":[{"id":"48ff778f3c66","title":"阻塞队列","parent":"99e1494d0aba","children":[{"id":"8791059fc957","title":"定义","parent":"48ff778f3c66","children":[{"id":"9c30dcf2f0e6","title":"当队列中的元素为空时，取元素的线程被阻塞。当队列的元素为满时，往队列添加元素的线程被阻塞","parent":"8791059fc957","children":[]}]},{"id":"0a3366e7d88d","title":"优点","parent":"48ff778f3c66","children":[{"id":"a7b96f3fbbc8","title":"自动唤醒被阻塞的线程，不需要像非阻塞队列那样需要考虑线程同步策略和线程唤醒策略","parent":"0a3366e7d88d","children":[]}]},{"id":"fe9d73813ad1","title":"分类","parent":"48ff778f3c66","children":[{"id":"7060759f2dd3","title":"ArrayBlockQueue","parent":"fe9d73813ad1","children":[{"id":"fef317892874","title":"定义","children":[{"id":"187a654205a2","title":"基于数组实现","children":[],"parent":"fef317892874"}],"parent":"7060759f2dd3"},{"id":"eb0bbab01b05","title":"使用","parent":"7060759f2dd3","children":[{"id":"19694e33ea13","title":"需要指定容器的长度","parent":"eb0bbab01b05","children":[]},{"id":"8311571475c8","title":"需要指定公平性和非公平性，默认为不公平性，不保证被阻塞时间最长的线程被唤醒","parent":"eb0bbab01b05","children":[]}]}],"collapsed":false},{"id":"6eae0e6ad886","title":"LinkedBlockQueue","children":[{"id":"68e2e9d6a07d","title":"定义","children":[{"id":"41f20c188cad","title":"基于链表实现，可以不指定长度","children":[],"parent":"68e2e9d6a07d"}],"parent":"6eae0e6ad886"}],"parent":"fe9d73813ad1"},{"id":"310c41a3903a","title":"PriorityBlockQueue","children":[{"id":"588d4880e9eb","title":"定义","children":[{"id":"22e480bb11f7","title":"每次出队的元素都是优先级最高的元素","children":[],"parent":"588d4880e9eb"}],"parent":"310c41a3903a"}],"parent":"fe9d73813ad1"},{"id":"53fb32a33471","title":"DelayBlockQueue","children":[{"id":"23f53ca7cf3a","title":"定义","children":[{"id":"29d7a0663546","title":"只要到了一定的时间后才能取元素","children":[],"parent":"23f53ca7cf3a"}],"parent":"53fb32a33471"}],"parent":"fe9d73813ad1"}]}]},{"id":"0265b8310c58","title":"非阻塞队列","parent":"99e1494d0aba","children":[{"id":"244dbc70c2b8","title":"定义","parent":"0265b8310c58","children":[{"id":"db82eeb87d89","title":"是一种先进先出模型，有数组和链表两种实现方式","parent":"244dbc70c2b8","children":[]}]},{"id":"278e1cda3f9d","title":"分类","parent":"0265b8310c58","children":[{"id":"0eb5d992a68c","title":"LinkedList","parent":"278e1cda3f9d","children":[]},{"id":"1b3037ae474c","title":"ArrayDeque","parent":"278e1cda3f9d","children":[]}]}]}]},{"id":"67fea938b1d7","title":"Map","parent":"1974991fe221","children":[{"id":"e8a4a3de02e7","title":"定义","parent":"67fea938b1d7","children":[{"id":"ea65b03f986e","title":"集合中的每个元素都包含键对象和值对像，键对象不能重复","parent":"e8a4a3de02e7","children":[]}]},{"id":"e7e7a47d3de0","title":"分类","parent":"67fea938b1d7","children":[{"id":"18fe374aea8f","title":"HashMap","parent":"e7e7a47d3de0","children":[{"id":"60ba0c235700","title":"定义","parent":"18fe374aea8f","children":[{"id":"afe2507b61d2","title":"不保证元素的有序性，查询效率比较高","parent":"60ba0c235700","children":[]}]}]},{"id":"72238a8be48a","title":"LinkedHashMap","parent":"e7e7a47d3de0","children":[{"id":"35bda8810eda","title":"定义","parent":"72238a8be48a","children":[{"id":"d67ac3434c6d","title":"基于双向链表实现，保证元素的顺序","parent":"35bda8810eda","children":[]}]}]},{"id":"95773eb3ec83","title":"TreeMap","parent":"e7e7a47d3de0","children":[{"id":"767c4301b317","title":"定义","parent":"95773eb3ec83","children":[{"id":"aa3a02b923d3","title":"基于红黑树实现，插入时可进行排序","parent":"767c4301b317","children":[]}]}]}]}]}],"parent":"root","collapsed":true},{"id":"ad7d78b6b4a4","title":"字符串","children":[{"id":"360a1b3a730d","title":"String","children":[{"id":"8b7b676d81c8","title":"定义","children":[{"id":"f01b7133dcf9","title":"String是一个对象，并且是不变的，每一次对String的改变实际上是返回一个新的String对象","children":[],"parent":"8b7b676d81c8"}],"parent":"360a1b3a730d"},{"id":"a72120b5cc0b","title":"相关","parent":"360a1b3a730d","children":[{"id":"a092c3fc4e5e","title":"每一次我们创建字符串，实际是先系统查看字符串符是否有该字符串。如果有，就返回该字符串的引用。否则，就在字符串池中创建一个新字符串，并返回引用","parent":"a72120b5cc0b","children":[]},{"id":"fadecd5b0cd8","title":"Stirng的+操作的实质是编译器自动创建StringBuilder对象，并调用StringBuffer对象的append()方法添加字符串。编译器会为每一个String对象创建一个StringBuilder对象","parent":"a72120b5cc0b","children":[]}]},{"id":"3af68d5ab8fe","title":"功能","parent":"360a1b3a730d","children":[{"id":"9540dd79641a","title":"字符串比较","parent":"3af68d5ab8fe","children":[]},{"id":"953f426e4f01","title":"字符串查找","parent":"3af68d5ab8fe","children":[]},{"id":"2df5191d7258","title":"字符串截取","parent":"3af68d5ab8fe","children":[]},{"id":"4f7b24c497cb","title":"字符串替换","parent":"3af68d5ab8fe","children":[]}]}],"parent":"ad7d78b6b4a4"},{"id":"a9587cc8d092","title":"StringBuilder","children":[{"id":"d60b1998aad9","title":"定义","children":[{"id":"48ebd0979b22","title":"类似于StringBuffer,不过它不是线程安全，性能相对比StringBuffer快","children":[],"parent":"d60b1998aad9"}],"parent":"a9587cc8d092"},{"id":"6ed2368bd52e","title":"应用场景","children":[{"id":"ff5d2cdf83bf","title":"频繁进行字符串的元素（追加，删除，修改等）","children":[],"parent":"6ed2368bd52e"}],"parent":"a9587cc8d092"},{"id":"1862fa277e72","title":"功能","parent":"a9587cc8d092","children":[{"id":"bc341cfdd2fb","title":"类似于StringBuffer","parent":"1862fa277e72","children":[]}]}],"parent":"ad7d78b6b4a4"},{"id":"4f0cdcc7ffe3","title":"StringBuffer","children":[{"id":"5772cc9abde8","title":"定义","parent":"4f0cdcc7ffe3","children":[{"id":"96609f6b4914","title":"StringBuffer类似于String,不过StringBuffer是可变的，每一次对StringBuffer的修改实际上就是对StringBuffer对象的修改","parent":"5772cc9abde8","children":[]},{"id":"aa11a3c80025","title":"StringBuffer是线程安全的","children":[],"parent":"5772cc9abde8"}]},{"id":"6428786bd5fe","title":"应用场景","children":[{"id":"3e781454aa9f","title":"适合于对字符串的修改，删除等，即侧重于对字符串的改变","children":[],"parent":"6428786bd5fe"}],"parent":"4f0cdcc7ffe3"},{"id":"1ebea3b72064","title":"功能","children":[{"id":"1f0b5a82be68","title":"许多方法和String提供的方法差不多","children":[],"parent":"1ebea3b72064"},{"id":"5c59ecce9ea5","title":"它自己提供了append,delete,insert","parent":"1ebea3b72064","children":[]}],"parent":"4f0cdcc7ffe3"}],"parent":"ad7d78b6b4a4"}],"parent":"root","collapsed":true}],"lines":{}}},"meta":{"id":"5aa33727e4b0fb5a6bef100a","member":"587a097ae4b098bf4ca2ed8f","exportTime":"2018-03-26 19:09:18","diagramInfo":{"category":"mind_free","title":"JAVA","created":"2018-03-10 09:38:47","creator":"587a097ae4b098bf4ca2ed8f","modified":"2018-03-26 19:08:19"},"type":"ProcessOn Schema File","version":"1.0"}}