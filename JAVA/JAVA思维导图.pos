{"diagram":{"image":{"height":200,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","width":200,"y":0,"x":0},"elements":{"id":"root","title":"java","leftChildren":[{"id":"788852e37325","title":"对象","children":[],"parent":"root"},{"id":"8a1dabfff9cc","title":"类","parent":"root","children":[]},{"id":"6720a3f601c8","title":"数组","parent":"root","children":[]},{"id":"7ea127fa9059","title":"I/O系统","parent":"root","children":[]},{"id":"36f1f275f0a7","title":"并发","parent":"root","children":[]},{"id":"e28a2717ba1a","title":"泛型","parent":"root","children":[]},{"id":"c9d3c9e08ac2","title":"接口","parent":"root","children":[]}],"structure":"mind_free","root":true,"theme":"paper","children":[{"id":"a9cc294390de","title":"多态","parent":"root","children":[{"id":"0750f8ecabd3","title":"定义","parent":"a9cc294390de","children":[{"id":"6130616d0f9e","title":"对于父类发出的消息，不同的子类有不同的响应","parent":"0750f8ecabd3","children":[]}],"collapsed":false},{"id":"476b94652b69","title":"实现","parent":"a9cc294390de","children":[{"id":"e4597f226f6d","title":"基于继承方式实现","parent":"476b94652b69","children":[{"id":"ea647ff0dd7b","title":"子类重写父类继承的方法，子类向上转型为父类引用，父类引用就可以调用子类重写的方法","parent":"e4597f226f6d","children":[]}]},{"id":"aa0cf2964f59","title":"基于接口方式实现","parent":"476b94652b69","children":[{"id":"0d7815a87434","title":"类实现接口，类向上转型为接口类型，接口类型就可以调用被实现的方法","parent":"aa0cf2964f59","children":[]}]}],"collapsed":false}]},{"id":"8353f540dc2c","title":"封装","parent":"root","children":[{"id":"fe13be26158b","title":"定义","parent":"8353f540dc2c","children":[{"id":"f4b4fa37757c","title":"对类的数据和方法进行限制，外部类不能随随便便得使用，需要使用定义类提供的外部接口","parent":"fe13be26158b","children":[]}]},{"id":"dadc2af068d2","title":"作用","children":[{"id":"63272b2120c0","title":"类的开发者可以很方便得修改自己的类，只要不改变外部接口的参数就不需要修改使用该类的客户端代码","parent":"dadc2af068d2","children":[]}],"parent":"8353f540dc2c"},{"id":"49872cd54025","title":"实现","children":[{"id":"7b07d01070a6","title":"根据需要把类的属性或方法定义为private,protect类型，把外部接口定义为public类型供外部使用","children":[{"id":"092e848eeaa8","title":"private","parent":"7b07d01070a6","children":[{"id":"c6cf76f5b701","title":"只有在定义类内才能使用","parent":"092e848eeaa8","children":[]}]},{"id":"88f5cae71627","title":"protected","children":[{"id":"dfc64dcc2bb9","title":"可以在本类，子类，同一个package的类使用，不同的package类不能使用","parent":"88f5cae71627","children":[]}],"parent":"7b07d01070a6"},{"id":"c60179408581","title":"public","children":[{"id":"b6ebb98fa1bf","title":"可以在任意地方使用","parent":"c60179408581","children":[]}],"parent":"7b07d01070a6"}],"parent":"49872cd54025"}],"parent":"8353f540dc2c"}]},{"id":"69bd992586ec","title":"继承","parent":"root","children":[{"id":"5399df2206fe","title":"定义","children":[{"id":"1f82e6d90aa7","title":"一个类继承了父类中所有的方法和属性","children":[],"parent":"5399df2206fe"}],"parent":"69bd992586ec"},{"id":"fdd304d975ee","title":"作用","parent":"69bd992586ec","children":[{"id":"e74b646a4fbe","title":"实现代码复用，父类抽取子类中共有的方法和属性","parent":"fdd304d975ee","children":[]}]},{"id":"722678602f0d","title":"实现","parent":"69bd992586ec","children":[{"id":"90879c047664","title":"使用extends关键字","parent":"722678602f0d","children":[]},{"id":"b3023bfbd884","title":"子类根据需要重写父类的方法或者添加新的属性或方法","parent":"722678602f0d","children":[]}]},{"id":"c163cbecb401","title":"缺点","children":[{"id":"51581cd67323","title":"父类变，子类一定变","children":[],"parent":"c163cbecb401"},{"id":"e850bf85813b","title":"破坏了封装，父类的属性或方法对子类可见","parent":"c163cbecb401","children":[]},{"id":"149458cd5e84","title":"继承是一种强耦合关系","parent":"c163cbecb401","children":[]}],"parent":"69bd992586ec"},{"id":"f367fb5806d0","title":"使用建议","children":[{"id":"829f4eadcf6d","title":"如果子类需要向上转型为父类，就一定得用继承","children":[],"parent":"f367fb5806d0"},{"id":"c9d67fd885f0","title":"尽量少用继承","children":[],"parent":"f367fb5806d0"},{"id":"011f76ab137b","title":"如果只是为了代码复用，尽量不要用继承","children":[],"parent":"f367fb5806d0"}],"parent":"69bd992586ec"}]},{"id":"58a723a419fc","title":"接口","parent":"root","children":[{"id":"154d5ae1530d","title":"定义","children":[{"id":"51f5dc9ff68e","title":"接口是一种比抽象类更抽象的类，没有具体实现","children":[],"parent":"154d5ae1530d"},{"id":"1f5eb2cd0a53","title":"接口定义了类与类的协议，任何实现该接口的类都像这样","children":[],"parent":"154d5ae1530d"}],"parent":"58a723a419fc"},{"id":"a9261438eb1d","title":"作用","children":[{"id":"d6b1265e9cb4","title":"java中没有多重继承，可以用接口来实现类似多层继承的特性","children":[],"parent":"a9261438eb1d"},{"id":"781181cdd7d7","title":"把接口当成参数，任何实现该接口的类都可以当成该接口的参数","children":[],"parent":"a9261438eb1d"}],"parent":"58a723a419fc"},{"id":"e28348b96302","title":"实现","children":[{"id":"8c5643d8fc25","title":"使用implements关键字","children":[],"parent":"e28348b96302"},{"id":"9642e16b7803","title":"根据需要重写方法","children":[],"parent":"e28348b96302"}],"parent":"58a723a419fc"},{"id":"16b5b12899fe","title":"建议","children":[{"id":"fb78910127d2","title":"优先选择类而不是接口","children":[],"parent":"16b5b12899fe"},{"id":"7a4be9b56f48","title":"接口是一种重要工具，但是它们容易被滥用","children":[],"parent":"16b5b12899fe"}],"parent":"58a723a419fc"}]},{"id":"1974991fe221","title":"容器","parent":"root","children":[{"id":"cf575d32c29b","title":"Set","children":[{"id":"e2ac1b69eb0d","title":"定义","children":[{"id":"f482e3847dbb","title":"不包含重复元素，是一个无序集合","children":[],"parent":"e2ac1b69eb0d"}],"parent":"cf575d32c29b"},{"id":"a1861683c192","title":"分类","parent":"cf575d32c29b","children":[{"id":"dc12846f0fad","title":"HashSet","parent":"a1861683c192","children":[{"id":"4d413b5ed3f9","title":"定义","parent":"dc12846f0fad","children":[{"id":"d0d60b003d22","title":"HashSet不保证元素的插入顺序","children":[],"parent":"4d413b5ed3f9"},{"id":"2554210da757","title":"基于散列表实现，存取的时间效率比较高，但空间效率比较低","parent":"4d413b5ed3f9","children":[]}]}]},{"id":"6289f16a581b","title":"TreeSet","parent":"a1861683c192","children":[{"id":"daed8ca16184","title":"定义","children":[{"id":"c9f1ffe2cf20","title":"保证元素的顺序","children":[],"parent":"daed8ca16184"},{"id":"310ec5069ba9","title":"支持自然排序和默认排序","children":[],"parent":"daed8ca16184"},{"id":"59f74e8ef9fd","title":"基于树结构实现，遍历和访问比较快","children":[],"parent":"daed8ca16184"}],"parent":"6289f16a581b"}]},{"id":"b1e5bd96f9b2","title":"LinkdedHaseSet","parent":"a1861683c192","children":[{"id":"45452353c286","title":"定义","parent":"b1e5bd96f9b2","children":[{"id":"64c21cd152e8","title":"保证元素的顺序","parent":"45452353c286","children":[]},{"id":"098b8b686b65","title":"访问性能比HashSet好，但插入时比HashSet的效率低","parent":"45452353c286","children":[]}]}]}]}],"parent":"1974991fe221"},{"id":"45fa0d62485f","title":"List","children":[{"id":"332adbd38336","title":"定义","parent":"45fa0d62485f","children":[{"id":"bc59673e445d","title":"list继承collection,是一个有序集合","parent":"332adbd38336","children":[]}]},{"id":"110910d5a244","title":"分类","parent":"45fa0d62485f","children":[{"id":"c5c8bce80132","title":"ArrayList","children":[{"id":"d9ba81822f91","title":"定义","parent":"c5c8bce80132","children":[{"id":"8e38575f2290","title":"基于数组实现，可以动态增长","parent":"d9ba81822f91","children":[]}]},{"id":"b491f516efca","title":"应用场景","parent":"c5c8bce80132","children":[{"id":"2032c16ef350","title":"适合应用于对插入速度要求不高，但是对数据的访问速度要求比较高","parent":"b491f516efca","children":[]}]}],"parent":"110910d5a244"},{"id":"1a56649d34a7","title":"LinkedList","children":[{"id":"09f0468fdd48","title":"定义","parent":"1a56649d34a7","children":[{"id":"bb4964568ca1","title":"基于链表实现，是一个双向循环链表，可当成栈来使用","parent":"09f0468fdd48","children":[]}]},{"id":"5ef80ef68307","title":"应用场景","children":[{"id":"7ad25aa86c28","title":"适合于对访问元素的速度要求不高，但对数据的插入和删除的速度比较高","children":[],"parent":"5ef80ef68307"}],"parent":"1a56649d34a7"}],"parent":"110910d5a244"},{"id":"168c9305c407","title":"Vector","children":[{"id":"42e71cfebbc9","title":"定义","children":[{"id":"532af0632525","title":"基于数组实现，线程安全","children":[],"parent":"42e71cfebbc9"}],"parent":"168c9305c407"},{"id":"454e2a8e8257","title":"应用场景","parent":"168c9305c407","children":[{"id":"85e096ddd1ad","title":"适合多线程访问元素","parent":"454e2a8e8257","children":[]}]}],"parent":"110910d5a244"},{"id":"761a3a8dc742","title":"Stack","children":[{"id":"08cb9161f439","title":"定义","parent":"761a3a8dc742","children":[{"id":"901a4c8b9551","title":"基于栈的实现方式，后进先出","parent":"08cb9161f439","children":[]}]},{"id":"31d33bf0d976","title":"应用场景","children":[{"id":"8fb932e2784b","title":"适合于要求元素后进先出","children":[],"parent":"31d33bf0d976"}],"parent":"761a3a8dc742"}],"parent":"110910d5a244"}],"collapsed":false}],"parent":"1974991fe221"},{"id":"99e1494d0aba","title":"Queue","children":[{"id":"48ff778f3c66","title":"阻塞队列","children":[{"id":"8791059fc957","title":"定义","children":[{"id":"9c30dcf2f0e6","title":"当队列中的元素为空时，取元素的线程被阻塞。当队列的元素为满时，往队列添加元素的线程被阻塞","children":[],"parent":"8791059fc957"}],"parent":"48ff778f3c66"},{"id":"0a3366e7d88d","title":"优点","children":[{"id":"a7b96f3fbbc8","title":"自动唤醒被阻塞的线程，不需要像非阻塞队列那样需要考虑线程同步策略和线程唤醒策略","children":[],"parent":"0a3366e7d88d"}],"parent":"48ff778f3c66"},{"id":"fe9d73813ad1","title":"分类","children":[{"id":"7060759f2dd3","title":"ArrayBlockQueue","children":[{"id":"fef317892874","title":"定义","parent":"7060759f2dd3","children":[{"id":"187a654205a2","title":"基于数组实现","parent":"fef317892874","children":[]}]},{"id":"eb0bbab01b05","title":"使用","children":[{"id":"19694e33ea13","title":"需要指定容器的长度","children":[],"parent":"eb0bbab01b05"},{"id":"8311571475c8","title":"需要指定公平性和非公平性，默认为不公平性，不保证被阻塞时间最长的线程被唤醒","children":[],"parent":"eb0bbab01b05"}],"parent":"7060759f2dd3"}],"parent":"fe9d73813ad1","collapsed":false},{"id":"6eae0e6ad886","title":"LinkedBlockQueue","parent":"fe9d73813ad1","children":[{"id":"68e2e9d6a07d","title":"定义","parent":"6eae0e6ad886","children":[{"id":"41f20c188cad","title":"基于链表实现，可以不指定长度","parent":"68e2e9d6a07d","children":[]}]}]},{"id":"310c41a3903a","title":"PriorityBlockQueue","parent":"fe9d73813ad1","children":[{"id":"588d4880e9eb","title":"定义","parent":"310c41a3903a","children":[{"id":"22e480bb11f7","title":"每次出队的元素都是优先级最高的元素","parent":"588d4880e9eb","children":[]}]}]},{"id":"53fb32a33471","title":"DelayBlockQueue","parent":"fe9d73813ad1","children":[{"id":"23f53ca7cf3a","title":"定义","parent":"53fb32a33471","children":[{"id":"29d7a0663546","title":"只要到了一定的时间后才能取元素","parent":"23f53ca7cf3a","children":[]}]}]}],"parent":"48ff778f3c66"}],"parent":"99e1494d0aba"},{"id":"0265b8310c58","title":"非阻塞队列","children":[{"id":"244dbc70c2b8","title":"定义","children":[{"id":"db82eeb87d89","title":"是一种先进先出模型，有数组和链表两种实现方式","children":[],"parent":"244dbc70c2b8"}],"parent":"0265b8310c58"},{"id":"278e1cda3f9d","title":"分类","children":[{"id":"0eb5d992a68c","title":"LinkedList","children":[],"parent":"278e1cda3f9d"},{"id":"1b3037ae474c","title":"ArrayDeque","children":[],"parent":"278e1cda3f9d"}],"parent":"0265b8310c58"}],"parent":"99e1494d0aba"}],"parent":"1974991fe221"},{"id":"67fea938b1d7","title":"Map","children":[{"id":"e8a4a3de02e7","title":"定义","children":[{"id":"ea65b03f986e","title":"集合中的每个元素都包含键对象和值对像，键对象不能重复","children":[],"parent":"e8a4a3de02e7"}],"parent":"67fea938b1d7"},{"id":"e7e7a47d3de0","title":"分类","children":[{"id":"18fe374aea8f","title":"HashMap","children":[{"id":"60ba0c235700","title":"定义","children":[{"id":"afe2507b61d2","title":"不保证元素的有序性，查询效率比较高","children":[],"parent":"60ba0c235700"}],"parent":"18fe374aea8f"}],"parent":"e7e7a47d3de0"},{"id":"72238a8be48a","title":"LinkedHashMap","children":[{"id":"35bda8810eda","title":"定义","children":[{"id":"d67ac3434c6d","title":"基于双向链表实现，保证元素的顺序","children":[],"parent":"35bda8810eda"}],"parent":"72238a8be48a"}],"parent":"e7e7a47d3de0"},{"id":"95773eb3ec83","title":"TreeMap","children":[{"id":"767c4301b317","title":"定义","children":[{"id":"aa3a02b923d3","title":"基于红黑树实现，插入时可进行排序","children":[],"parent":"767c4301b317"}],"parent":"95773eb3ec83"}],"parent":"e7e7a47d3de0"}],"parent":"67fea938b1d7"}],"parent":"1974991fe221"}]},{"id":"ad7d78b6b4a4","title":"字符串","parent":"root","children":[]}],"lines":{}}},"meta":{"id":"5aa33727e4b0fb5a6bef100a","member":"587a097ae4b098bf4ca2ed8f","exportTime":"2018-03-17 15:52:23","diagramInfo":{"category":"mind_free","title":"JAVA","created":"2018-03-10 09:38:47","creator":"587a097ae4b098bf4ca2ed8f","modified":"2018-03-17 15:49:55"},"type":"ProcessOn Schema File","version":"1.0"}}